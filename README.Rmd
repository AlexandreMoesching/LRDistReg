---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# LRDistReg

<!-- badges: start -->
<!-- badges: end -->

Consider bivariate observations $(X_1, Y_1), \ldots , (X_n, Y_n) \in \mathbb{R}\times\mathbb{R}$ with unknown conditional distributions $Q_x$ of $Y$, given that $X = x$. The goal is to estimate these distributions under the sole assumption that $Q_x$ is isotonic in $x$ with respect to likelihood ratio order. The main algorithm of this package estimates the unknown family
of distributions $(Q_x)_x$ via empirical likelihood, see [Moesching and Duembgen](https://arxiv.org/abs/2007.11521).

Most functions are implemented both in R and C++ in order to have an easy to read implementation and a fast one.

## Installation

You can install the development version of LRDistReg from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("AlexandreMoesching/LRDistReg")
```

## PART 1: True model (parametric)

The present demo uses a gamma family of distributions $(Q_x)_{x\in \mathfrak{X}}$. More precisely
$Q_x := \mathrm{Gamma}\bigl(a(x), b(x)\bigr)$ for all $x \in \mathfrak{X} := [1,4]$, with some shape $a: \mathfrak{X} \to (0,\infty)$ and scale $b: \mathfrak{X} \to (0,\infty)$.
```{r true_family_of_distributions}
rm(list = ls())
set.seed(111)
a <- function(x) 2 + (x+1)^2
b <- function(x) 1 - exp(-10*x)
r.cond.dist <- function(x) rgamma(1, shape = a(x), scale = b(x))
p.cond.dist <- function(x, y) pgamma(y, shape = a(x), scale = b(x))
d.cond.dist <- function(x, y) dgamma(y, shape = a(x), scale = b(x))
q.cond.dist <- function(x, alpha) qgamma(alpha, shape = a(x), scale = b(x))
```

Visual output of the true family of distributions. For each $(x,y)$ in a certain rectangle, the value of $(\mathrm{d}Q_x/\mathrm{d}y)(y)$ is given by the color scale.
```{r visual_output}
xx <- seq(1, 4, length.out = 2e2)
yy <- seq(q.cond.dist(1, 0.05), q.cond.dist(4, 0.95), length.out = 2e2)
lattice::levelplot(outer(xx, yy, FUN = "d.cond.dist"), 
                   nlevels = 1e2, aspect = "fill",
                   col.regions = hcl.colors(1e2),
                   row.values = xx, column.values = yy,
                   xlab = expression(italic(x)), ylab = expression(italic(y)),
                   xlim = range(xx), ylim = range(yy))
```

## PART 2: Small data example, first nonparametric fit

Let us start with a small sample: $n = 30$ observations with covariates in a set $\mathfrak{X}_o := 1 + 3*\{1,2,...,\ell_o\}/\ell_o$, for $\ell_o = 10$.
```{r basic_parameters}
n <- 30
l0 <- 10
x0 <- 1+(1:l0)/l0*3
```

Generate observation pairs $(X_1,Y_1),(X_2,Y_2),...,(X_n,Y_n)$.
```{r generate_data}
X <- sort(sample(x0, size = n, replace = TRUE))
Y <- rep(0, n)
for (i in 1:n) Y[i] <- r.cond.dist(X[i])
```

We now estimate the family of distribution. We use the function `dist_reg_R()` with default options.
```{r fit}
library(LRDistReg)
res <- dist_reg_R(X, Y)
plotD(res$par, indices = FALSE)
```

The design of the experiment should be shown. The color of a pair $(x,y)$ is equal to the number of observations at that location, plus 1. In consequence, black points contain no observations, red points contain one observation pair, green points contain two observation pairs, etc.

The family of distributions is estimated at each points of this grid. The estimated conditional distribution functions are given by `res$CDF_LR`, an $\ell$-by-$m$ matrix.
```{r show_results, results=FALSE}
res$CDF_LR
```

One can also retrieve the jumps only.
```{r show_jumps, results=FALSE}
res$q_LR
rowSums(res$q_LR)

res$h_TP2
rowSums(res$h_TP2); res$par$w_j.plus/res$par$n
colSums(res$h_TP2); res$par$w_plus.k/res$par$n
```

## PART 3: Medium data example, specification of precision parameter

The new setup is specified as follows:
```{r medium_options_and_data}
n <- 1e2
l0 <- 10
x0 <- 1+(1:l0)/l0*3

X <- sort(sample(x0, size = n, replace = TRUE))
Y <- rep(0, n)
for (i in 1:n) Y[i] <- r.cond.dist(X[i])
Y <- round(Y, 1) # Should create some ties
```

This time we obtain the fit using a self-specified value of the precision parameter $\delta_o$.
```{r fit_medium}
res <- dist_reg_R(X, Y, delta0 = 1e-4)
```

## PART 4: A larger data example, comparison between Likelihood-Ratio ordering, usual STochastic ordering and the EMPirical

```{r options_and_data_large}
n <- 1e3
l0 <- 1e2
x0 <- 1+(1:l0)/l0*3

X <- sort(sample(x0, size = n, replace = TRUE))
Y <- rep(0, n)
for (i in 1:n) Y[i] <- r.cond.dist(X[i])

res <- dist_reg_R(X, Y, delta0 = 1e-2, ST = TRUE)
```

Retrieve all CDF's and some useful parameters.
```{r retrieve}
x <- res$par$x
y <- res$par$y
l <- res$par$l
m <- res$par$m

CDF_LR <- res$CDF_LR
CDF_ST <- res$CDF_ST
CDF_EMP <- res$CDF_EMP
CDF_TRUE <- outer(x, y, p.cond.dist)
```

Evaluate estimation quality.
```{r evaulate_quality}
DIFF_LR <- sum(abs(CDF_LR - CDF_TRUE))/(l*m)
DIFF_ST <- sum(abs(CDF_ST - CDF_TRUE))/(l*m)
DIFF_EMP <- sum(abs(CDF_EMP - CDF_TRUE))/(l*m)
c(DIFF_LR, DIFF_ST, DIFF_EMP)
```

Plot the true CDF as well as its estimators for two values of $x$, one 
middle covariate ($x = 2.5$) and one boundary covariate ($x = 4$).
```{r plot_fit}
plot(0, type = "n",
     xlab = expression(italic(y)), ylab = expression(italic(G[x](y))),
     xlim = range(y), ylim = c(0,1), lwd = 2)
for (xj in c(2.5, 4)) {
  j <- which(xj == x)
  lines(y, CDF_TRUE[j,],lwd = 2)
  lines(y, CDF_EMP[j,], lty = 2)
  lines(y, CDF_ST[j,], col = 2, lwd = 2)
  lines(y, CDF_LR[j,], col = 3, lwd = 2)
  legend("topleft", 
         legend = c("True", "EMP", "ST", "LR"),
         col = c(1,1,2,3), lty = c(1,2,1,1), lwd = c(2,1,2,2))
}
```

The LR-estimator is in general smoother than the ST-estimator. In this specific example, the LR-estimator is also closer to the true distribution than the ST-estimator. This was confirmed already earlier when looking at average absolute differences. 

## PART 5: Interpolation feature

In case the estimators are desired for other values of $x$ than those provided by the set of covariates, it is still possible to obtain the estimated CDFs at these other $x$'s using linear interpolation
```{r show_linear_interpolation}
n <- 50
l0 <- 50
x0 <- 1+(1:l0)/l0*3

X <- sort(sample(x0, size = n, replace = TRUE))
Y <- rep(0, n)
for (i in 1:n) Y[i] <- r.cond.dist(X[i])

res <- dist_reg_R(X, Y, ST = TRUE)
dim(res$CDF_LR); dim(res$CDF_ST); dim(res$CDF_EMP)
res <- dist_reg_R(X, Y, x0 = x0, ST = TRUE)
dim(res$CDF_LR); dim(res$CDF_ST); dim(res$CDF_EMP)
```
